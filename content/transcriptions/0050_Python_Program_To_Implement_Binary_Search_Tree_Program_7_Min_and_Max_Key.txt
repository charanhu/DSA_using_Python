 Hello guys and welcome to Python programming tutorials by Amoleas Academy. We are discussing about binary search tree implementation. Today in this tutorial we will write a method to find the node with the minimum key that is the smallest key and node with the maximum key that is the largest key in given tree. So first let's discuss about the node with the smallest key. When a tree is given and if I want to find the node with the smallest key then I need to find that node in the left side right. The leftmost node will be the smallest node in the binary search tree. Because binary search tree is structured like that. If we have a node with key less than the root nodes key then that will be present in the left side. So now if I want to find the node with the smallest key then I need to search in the left subtree of the root node and in the left subtree also the leftmost node will be the node with the smallest key. Now here in this example this is the node with the smallest key. But in this second example you can see this root node doesn't contain left subtree. So this is the smallest node in this tree. If left subtree is not present then the root node will be the node with the smallest key. Alright now in this tutorial I need to write a method to find the node with the smallest key in given tree. So for that what I'll do is I'll begin from the root node and I'll check whether root node contains left child. If the left child of root node is present that means root node is not the node with the smallest key. If the root node doesn't contain the left child that means root node will be the node with the smallest key. So that's why we need to check whether the left child of root node is present or not. In this case it is present right. So what I'll do is I'll go here and I'll check whether this node now contains the left child or not. Yes the left child of this node is present here. So I'll go here and I'll check whether this node contains the left child. We are not giving importance to the right child because we know the smallest node will be present in the left side. That's why we are concentrating only on the left child. So now here I'll check whether this node contains the left child. Yes here we can see. So that's why I'll come here and I'll check whether this node contains the left child. Here no right. That means this is the smallest node of the given tree. So I'll print that. Here coming to this case left child of this root node is not present. So this node will be the smallest node of the given tree. So I'll print that. So to write the method. So here we have class BST binary search tree. In that we have insert method search method and traversal methods. Next we have delete method. After this let me write method to find the node with the smallest key in given tree. So here I'll give the method name as minimum node min underscore node. You can give any suitable name and here I'll take the first parameter as self and we don't need any other parameter because here we are searching for the node with the smallest key right here. We need to start from the root node right. So I'll take a variable current and I'll take root node here. Here as I said to get the node with the minimum key we need to start from the root node right. That's why here I'm taking a name for the root node that is current. Now current is a variable which is pointing to the root node now. Next here I need to check whether left child of root node is present or not. Here current is pointing to that. So this will become current dot lchild. I'll check whether current dot lchild is present or not. Here it is present right. That's why I'll take this as current now. Current equal to current dot l child. So this will become current I'll make this as current now. Next again I'll check whether l child of this current node is present or not. Here it is present right. That's That's why I will take current equal to current dot l child. I am taking like this current is equal to current dot l child. So now current will point here. Now again I will check whether l child of this node is present or not. Yes it is present right. That's why I will execute this again. I will make this as current. Now again I will check whether l child of this current node is present or not. No it is not present right. That means this is the node with the smallest key. So I will print its data current dot key. Print its data. First we need to take root node as the current node. I am taking a variable and I will check whether it contains l child. If l child is present then I need to take current equal to current dot l child. I will make that l child as current. I will point variable current to the current dot l child. So this will become current. Then I will check whether this node contains l child. If it is present then I need to do this again. I need to point current to this node now. Until current dot l child becomes none we need to execute this again and again. That's why here I will use a loop. I will use while loop and l child current dot l child whether l child of current is present. Here initially current will point into the root node. The self is pointing to the object. We will call this method with the root object root dot minimum node. So root becomes self here. So initially when I take current equal to self that is nothing but current equal to root here in this program. So current is pointing to the root node. So I will check whether current dot l child is present. If it is present what I need to do I need to take current is equal to current dot l child. I will make that l child as current now. I will point current variable to its l child. We will execute this until this current dot l child becomes none. When I get a node which doesn't contain l child this condition becomes false. At that time I need to print its data. So here I will print the data current dot. Okay. Now we are done. So if a tree doesn't contain left subtree of the root node like this at that time current equal to self current points to the root node then it will check while current dot l child it doesn't have any l child this condition becomes false. So it will print this message it will print root node key root node is the smallest node now. When left subtree is not root node is the smallest node. So in this way we can find the node with the smallest key in given tree. Now let's talk about the node with the largest key maximum key in given tree. Now if I want to search for the node with the maximum key then I need to search that in the right side of the root node in the right subtree. For example in this tree this is the node with the maximum key. Here this is the node with the maximum key. It will be present in the right most side right side of the root subtree and if right subtree is none then root node will be the node with the maximum key like this in this example. So to find the node with the maximum key we will use the same method like we did with the node with the minimum key. First we will start from the root node and we will check whether its right child is present or not. Here if I start from the root node okay I will take it as current and I will check whether current dot r child is present. If it is present then I will point current to here. Here I need to take current is equal to current dot r child. Here we are talking about the node with the maximum key. So you need to search that node in the right side that is why current dot r child. So now current will point to here then I need to check whether current dot r child is present. If right child is not present that means this is the node with the maximum key. So we need to stop here and we need to print its data. Here we can see it does not have right child that is why this is the node with the maximum key. So I will print its data. Now here in this example I will point here this will be current first. So I will check whether it contains right child. I will use while loop. So I will first check while current dot r child. Yes it is present. So I will point current here. I will execute this current equal to current dot r child and now this is current then again I will check whether it contains right child. Yes it is. I will again execute this current equal to current dot r child. So now current will point to here then again I will check whether this node contains right child current dot r child is present or not. Here it is not present. So this is the node with the maximum key. So I will print its data. So in the program DES here I will take mags node. You can take any suitable name. We do not need any other parameter. I will take current is equal to self. So we need to start from the root node. I will take while current dot r child because we are talking about the node with the maximum key. So current dot r child if it is true then I need to take current is equal to current dot r child. After executing this while loop we will get the node with the maximum key. We need to print that and if you ask why I am using loop here while loop because we need to execute this line again and again until r child becomes none. That is why here we are using a loop. Alright so now we are done with the program. So let's execute this. So here I don't want to delete anything. So I will remove this. Let's call root dot minimum node. Next I will call root dot maximum node. And let me execute this. So here we can see it is in the preorder node with the smallest case one. Note with the maximum key is 98. Correct right. Now if I include 100 here I will get 100 here you can see. Okay so now if I want to find the node with the smallest key or maximum key largest key. First I need to start from the root node and if I want smallest key then I need to search in the left subtree. If I want node with the largest key then I need to search in the right subtree. If left subtree is none then the root node will be this node with the smallest key. If right subtree is none then root node is the node with the maximum key. Okay so this is about the node with the minimum and maximum key in binary search tree. So that's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet you in next class till then take care.