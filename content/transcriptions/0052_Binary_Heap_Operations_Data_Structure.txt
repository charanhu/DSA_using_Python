 Hello guys and welcome to Amulya's Academy YouTube channel. We are discussing about binary heap data structure and in the previous tutorial we discussed about its definition and about max heap and min heap and also we discussed where we can use binary heap data structure. Today in this tutorial we will talk about binary heap operations and the first operation of binary heap data structure is heapify. So let's see what is this heapify operation, what it will do. heapify is a process to rearrange the elements of the heap in order to maintain the heap property. Or heapify is an operation applied on nodes of heap to maintain the heap property. This operation makes sure that every node of a binary heap follows the heap property. This operation is used to create binary heap from the binary tree. It is used to create min heap or max heap. That is if we have a complete binary tree to make it as binary heap we need to apply the heap property to that right. And the process of applying the heap property is called as heapify operation. That's why we are saying it is used to create binary heap from the given complete binary tree. Alright, so next let's see where we can use this heapify operation. The first situation is when we insert a new node to binary heap, the entered node may or may not follow the heap property. So at that time we need to make sure that that entered node follows the heap property. So that time we need to perform heapify operation. And the second situation is when we are deleting the node from the binary heap. After deleting a node we need to rearrange the nodes. At that time we need to apply the heapify operation. And the third situation is when we ask to create a binary heap from a array of numbers. At that time we need to perform the heapify operation. And we can perform this heapify operation in two ways. Or we can say there are two types in this heapify operation that is called as heapify up and heapify down. heapify up operation follows the bottom up approach. In this we check if the nodes are following the heap property by going in the direction of the root node. We will compare the node with its parent. And we will see whether these nodes are following the heap property. If it is not then we will rearrange the nodes. Here you can see. And next we will move upwards. And we will compare this node with its parent. And we will see whether it follows the heap property or not. It can be max heap or min heap. If it follows then no need to do anything. If it does not follow then we need to rearrange the nodes. So here we are moving upwards. That is why this is called as heapify up. And we will perform this operation when we insert a new node to the binary heap. We will perform this operation that is heapify up. We will start from the lower level and we will move towards the upper level. And this heapify up operation is also called with many other names. So I will mention all other names here. You can see that. All right. So this is about heapify up. Next let's move on to the heapify down operation. heapify down operation follows the top down approach. In this we check if the nodes are following the heap property by going in the direction of the leaf nodes. And if nodes are following heap property then no need to do anything. If it is not then I need to rearrange the nodes. Here we can see this root node contains two child nodes. If I take some value like this and if it is a min heap. If we have values like this we want min heap here but this root node is 10 and its child node is 2 and 6. So it is not following the heap property. Now I need to rearrange the nodes. For that what I will do is I will check this child nodes which node contains the smallest value because we want smallest value here. Here this too. So I need to interchange this too. I need to swap this too. So here 2 comes here, 10 comes here. Now here you can see it is following the heap property. Right. Now we will move towards the lower side. We are moving downwards. Right. That's why this is heapify down operation. And we will perform this operation when we delete the root node from the binary heap. So we will discuss about this insertion and deletion operations separately. At that time we will understand how this heapify up and heapify down operation works. And there are some other names for heapify down operations. I will mention all the other names on this screen. And if you are performing heapify operation for the max heap. That is we are performing heapify operation to make complete binary tree max heap. Then that operation is called as max heapify. And if you are dealing with the main heap then that operation is called as min heapify. Okay. So this is about the heapify operation. Okay. So next let's move on to the next operation of the binary heap. That is insertion operation. The process of inserting a new node to binary heap by maintaining the binary heap property is called as insertion operation. That is when I insert a new node to binary heap I need to be careful about binary heap property. Here the task is to insert the new element to the binary heap maintaining the heap properties. We need to maintain the complete binary tree structure as well as heap order property. So whenever we want to insert a new node to the binary heap what we will do is first we will think about the complete binary tree structure. We need to maintain the complete binary tree structure. In order to maintain that we must add a new node to the first open spot available in the lower level, bottom level or the last level. After that we will chuck by adding the new node whether we are violating the heap property. If it is following the heap property then no need to worry about anything. If it is not then we need to heapify that. We need to rearrange the nodes. So these two are the steps of insertion operation. I will explain you with the example then you will understand this how it works. We have a binary heap here this is a min heap. Why I am saying this is a min heap? Because root node contains the smallest key and if I chuck all other nodes we can see the key of the parent node is smaller than the key of the child nodes. So this is a min heap. Now I want to add new node to this binary heap. For example two. The node is two. First step is we need to add the new node at the open spot available in the bottom level. Here we can see this is the level 0 level 1 level 2. This is the bottom level. Here open spot is not available. This level can contain at most four nodes and it is present. This level is completely filled here because this is a complete binary tree and in binary tree every node can contain maximum two child node and it is present here. So that means there is no open spot so I need to move towards the next level. That is I need to add here in the left side of this node. So here I need to add this new node. Now this is complete binary tree right because all the nodes are completely filled except the last level and in the last level the node is present in the left side. Okay so this is a complete binary tree. So now a complete binary tree structure is maintained. Next we need to check whether it is following the heap property or not. If it is not following then we need to rearrange the nodes. We need to perform heapify operation. So if I check the key of child node with its parent here we can see it is 2 and 10. Parent key greater than the child nodes key. This is a main heap so to maintain the property what I need to do I need to perform heapify operation here right. Here I need to move to here because 2 is smaller. So here I need to swap this to 10 and 2. 2 comes here and 10 here. 2 is moved here. Next again I need to check whether it is following the heap property here. So I will check 2 with its parent. Now 6, 2 and 6. No because here 6 is greater. 6 is the parent node and it contains key greater than the child nodes key. So here we want a main heap. In main heap parent node should contain smallest key. So we need to swap this to. So 2 moves here and 6 comes here. Now we need to compare 2 with its parent node that is phi. Its key is phi. Here we want minimum heap. So this node is not following the minimum heap property. Now we need to place 2 here. So we need to swap these two numbers. Phi here and 2 will move here. We don't have any other node after this node. So we can stop the comparison now. Now here you can see every node is following the minimum heap property. So insertion is done successfully. Initially 2 was placed here. We compared the nodes in the upward direction. So that's why this process is called as heapifyup operation. Next let's take another example. Now what I need to do is I need to insert these nodes to the binary heap. Now binary heap is completely empty. So let's start. First I need to insert 4. So I'll insert like this 4. We don't have any other node to compare. So just add 4. Next 10. Here we need to add it to the first open spot. I need to add here. Now I need to check whether it is following the heap property. Here I want to construct a max heap. So in max heap, key of the parent node will be greater than the key of the child node. Here we can see this is the child node and this is the parent node. Here child node key is greater than the parent node. So I need to swap this. So here we'll get 10 comes here and we'll get 4 here. Next value is 3. The next open spot is here. So I'll add this here and I'll check whether it is following the heap property. Yes, because here parent node contains the key greater than the child node key. So it is following the max heap property. So I'll go to the next value 1. See next open spot is here. So I'll add that here 1 and it is following the heap property. Its parent key is greater than its key. So no problem. Next let's see 6. So here open spot available is here 6. But here we can see its key is greater than its parent key. So what we need to do? We need to swap that, right? So 6 will come here. 4 will come here. Now again I need to check its key with its parent whether it is violating the heap property. Here no, it is 6 and 10. The parent key is greater than its key. So no problem. So next let's move on to the next value that is 18. And the open spot available here is this, its left child. So I'll add here 18. And next let's check whether it is violating the heap property or not. Here 18 and 3. Yes it is violating the heap property. So we need to swap this. Swap 3 and 18. 18 come here. 3 here. Now again I need to check whether this node is violating the heap property. 18 and 10. Yes because here parent node key is less than the child node's key. So we need to swap that. Here 18 and 10. 18 will come here and now 10. We don't have any other node to add and we are done. So we'll get this binary heap. And here you can see this is a max heap and it is following the max heap property. So while performing the insertion operation first we need to be careful about the complete binary tree structure. That's why we need to add the new node to the first spot available in the bottom level. And after that we need to check whether that node is violating the heap property. If yes then you need to perform the heapify operation. Here in the insertion we'll perform the heapify up operation. So this is about the insertion operation. Next let's move on to the next operation that is deletion operation. So the next operation of binary heap data structure is deletion. It is the process to remove a node from the binary heap by maintaining the binary heap property. That is while deleting the node we need to make sure that after deleting that node trees must maintain the complete binary tree structure as well as heap order property. And the standard deletion operation of the binary heap is to delete the root node of the binary heap. But here I'll show you how to delete the root node as well as any node of the binary heap. So after deleting a node from the binary tree we must maintain the binary heap properties that is complete binary tree structure as well as heap order property. So that's why first we'll replace the root or the element to be deleted by the last element. Last node. Then we'll delete the last element from the heap. Lastly we'll heapify the binary heap. Okay here now if I want to delete root node the first step is we need to replace this root node with the last node. So we'll swap them. Now after that we'll remove this. Then now we need to heapify this tree. That's why we'll perform heapify operation. These are the steps we need to follow while deleting the node from the binary heap. I know it is a little bit confusing so let's take example then you'll understand how it works. So first I'll take this example. This is a minimum heap and here we'll delete a node which is not a root node. So let's delete phi. So first step is we need to replace this node the node which I want to delete with the last node of this binary heap. Here the last node is this. This is the last node. So we need to swap these two. Now 10 will come here and phi will go here. Now we wanted to delete phi. Now phi is here so delete this. Now phi is deleted. And now we maintain the complete binary tree structure also. Now what we need to do we need to chuck for the heap property whether it is following the heap property or not. That's why I'll compare this key with the its parent key. We'll chuck whether this node is following the heap property. Here it is yes. It is a min heap and here 2 is smaller than 10. So this is following the min heap. Then I'll chuck this node with its children whether it is following the heap property or not. Here it is 6 and 16 and here we want min heap. Here we have a node with smaller key than this key. So we need to swap these two. So here 6 come here, 10 comes here. We can say every node is following the heap property. The minimum heap property. The node phi is deleted from the binary heap and also we maintain the binary heap property. This is a complete binary tree and here every node is following the heap property. So while deleting the node first step is we need to replace that node with the last node of the binary heap. Then we need to remove the last node and next we need to heapify the tree. So next I'll show you another example where we'll delete the root node. So here we have another tree. This is the max heap. Here we can see root is 80, 6 and 10. It is 3, 4, 5, 7 and 1. So it is a complete binary tree as well as it is following the max heap property. It is a max heap. Now here I want to delete 18 the root node. The first step is we need to replace the node which I want to delete with the last node. We need to swap that. So here it will become 1. It will become 18. So this is 1 and here 18. Now next step is we need to remove the last node. Last node is 18. Now so remove that. Now we are done with the deletion and we also maintain the complete binary tree structure. Now the last step is we need to heapify the tree. So we need to start from the root node and I need to chuck whether this node is following the heap property or not. Here we can see parent nodes key is 1. Child node key is 6 and 10. Here we want max heap. So this node is not following the binary heap property. That's why we need to rearrange the nodes here. I need to replace this node with the 10 because in the child node key 10 is the greatest key. That's why I need to replace that here. So here 10 comes here and here this is 1. We replace this node. Now that's why I need to heapify this node. Now so I'll chuck whether this node is following the heap property or not. Its key is 1. Its child key is 5 and 7. So it is not following the heap property. That's why I need to replace this node with the this node. I need to swap these two nodes because in the child nodes key this is the largest key. So here this is 7 and here one will come here. Now if I chuck every node every node is following the heap property and in this way we can delete the root node. Okay so while performing the deletion operation the first step is we need to replace the node which I want to delete with the last node. Secondly we need to delete the last node. Thirdly we need to heapify the tree. All right so this is about the deletion operation and the next operation of binary heap is you can extract min or max node in the min or max heap respectively. If we have max heap we can extract node with the maximum key. If we have min heap we can extract node with the minimum key. Extract is nothing but we will print the node of the maximum key or minimum key and we'll delete that from the binary heap. It is like printing the root node key and deleting the root node. I already explained you how we can delete the root node right. In this operation we will print the root node value and we'll delete the root node. And the next operation is get max or min. So if we have max heap we can get the node with the maximum key. If we have min heap we can get the node with the minimum key. We just need to print the root nodes key that's it. Okay so these are the operations of binary heap. So that's it for now guys thank you for watching don't forget to subscribe to my channel I will meet you in next class till then take care.