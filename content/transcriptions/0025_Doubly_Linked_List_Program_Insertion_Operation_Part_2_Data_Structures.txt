 Hello guys and welcome to Python programming tutorials by Amelia's Academy. We are discussing about doubly linked list program and in that, previously we wrote the program for the traversal operation as well as few scenarios of insertion operations. That is we wrote the method to insert the new node in the empty doubly linked list at the beginning of the linked list and at the end of the linked list. Today we will discuss about the rest scenarios. That is how to insert new node after the given node or before the given node. There are a few similarities between these two methods that is add after and add before methods. Here add after method will add the element or new node after the given node and add before method will add the new node before the given node. Today we will write the code for these two methods. First we will see the similarities between the two methods. In both the methods, first we will check doubly linked list is empty or not. If doubly linked list is empty, that means we can't add any new node after the given node before the given node. There is no node present in the doubly linked list. Here in the add after and add before method, we need to add the new node after the given node or before the given node. If that given node is not present in the doubly linked list, then how to add the new node, right? That's why first we need to check this. In both the methods first we need to check the doubly linked list is empty or not. If it is empty, print a message. If it is not empty, then traverse to that position, traverse to given node. So in my program, in both this method, I'll take x as the given node. So I need to traverse to x here. Go to that node mentioned node, then in add after method, add the new node after the x and in add before add the new node before x. So these are the steps we need to follow while writing these two methods. So first let's write the code for add after method. So here we have a program class node class doubly linked list in that we have two methods for traversal operation forward traversal and backward traversal. Next we have three methods for insert operation, insert empty add begin and add end. So link of all the videos are in the description box, you can go and check the video. Next today here we need to create the add after method add after I'll take the method name as add after next the first parameter is self. Next you need to take data. So we are inserting the new node in every node, there is a data field, right? So we need to insert the data as well as we need to insert x x is nothing but the given node after which we need to insert the new node. So here I'll mention x as the data data of the node. For example, if my doubly linker list contains 10, 20 and 30 and if I want to insert the new node after 20, then I'll take x as the 20. So here x is the data of the node. Next first step is we need to check doubly linker list is empty or not to check the linker list is empty or not we need to use self head is none or not. So I'll take if condition and I'll check self dot head is none. If it is none, that means linker list is empty. So you can't print any message here like linker list is empty. So you can't insert like that. You need to write a message. If linker list is empty, that means x is not present in the doubly linker list, right? So that means we can't insert the new node after x. That's why we need to check this condition. Else if linker list is not empty, then we need to traverse to the x node, the given node. So now the question is how to go to the node x. So for that you need to traverse from the beginning, you need to start from the first node. Here we have few nodes. So if doubly linker list is not empty, that means it contains one or more nodes and x can be any node to traverse to that node to reach that node. We need to start from the first node. So for that first, I'll take n equal to self dot head. Okay. So the first node will become a n because head contains the reference of first nodes. So you need to take n equal to self dot head, then to go to the next node, you need to change the n value like this n equal to n reference. And we need to check data of every node with the x, because as I said, x is the data of the given node. So for that, I'll use if condition and I'll check like this, if x is equal to n dot data. Initially, I'll take the first node as n, right? So n dot data is nothing but 10. I'll compare 10 with the x value. If x equal to equal to n dot data, if it is true, that means we got the x, we found the x, n is pointing to x. Now, if it is not, then I need to increment the n value. I need to go to the next node. Now, n becomes this. And again, I need to check x with the n dot data 20 with the x. If it is true means we got the x. Otherwise, again, I need to go to the next node, and I need to check the data of that node with the x, I need to compare the data of that node with the x. So we need to repeat this again and again, that's why I need to include this in a while loop. And here I need to take condition as while n is not none. Until n becomes none, I need to execute this. Here, when this node is n, this is the last node here, you can see first, you need to compare this that is n dot data 30 with the x, whether it is equal. If it is not, then I'll increment n value. So n becomes none. At that time, I need to stop. That's why here I need to take while n is not none. Chuck f x is equal to n dot data. If it becomes true, execute break statement. That is nothing but we found the x node. That is the given node. Now, stop moving to the next node. That's why you need to execute this break statement. When you use break statement inside a while loop, when that break statement is executed, it will come out of the loop. If x is not equal to the n dot data, then you need to go to the next node. So for that, you need to change n value to n dot n reference. In this way, you can move to the x, you can find the x. So here, initially take n is equal to self dot head. Next here, use while loop and chuck while n is not none, while n is not none. If it is not none, you need to chuck if x is equal to n dot data. You need to use the comparison operator double equals. And if it is true, execute the break statement. If it is not, then go to the next node. So for that, you need to take n equal to n dot n reference. Now here, control will come out of the while loop because of two condition. One is because of the execution of this break statement or another one is when n becomes none. If n becomes none, it will come out of the loop or when we found the x value, it will come out of the loop. We need to take that two condition. That's why here, I'll use if condition and I'll chuck if n is none. If n is none means we served for x in the entire w-linked list, but we didn't found that. That means if n is none, given node is not present in the w-linked list, the ll, the blue-linked list. Look here, we'll go to every node and we'll chuck its data with x, we'll compare its data with x. If we found that it will execute the break statement. If the data of the nodes didn't match with the x, then we'll go to the next node and we'll compare its data. But if x is not present in the w-linked list, then break statement won't execute. Instead of that, n becomes none. After completing every node, n will reach to the last node and after comparing its data, n becomes none. So at that time also, control will come out of the while loop. So first we need to chuck that condition. If n is none, that means the given node is not present in the w-linked list. Else, if n is not none, that means break statement is executed. That means we found the x. Now we know where x is present. Now n is pointing to x. Now what we need to do? Let's see that. Now after finding the x, what we need to do? We need to add the new node after the given node. So for that first step is you need to create the node. So create node using node class. Next, because every node of the w-linked list contains previous reference as well as next reference, when you are adding the element after the given node, you need to be careful about one thing. That is, whether you are inserting the new node after the last node. You need to write this special condition for this. You need to be careful about this scenario. Because every node contains previous reference and next reference, because of that, you need to be careful about this. Whether you are inserting the new node after the last node. And here next is rest case, rest nodes. That is after the second node, after the first node, or after the middle nodes. Here, while writing this method, you need to be careful about one thing. That is, you need to chuck whether you are inserting the node after the last node. I'll tell you why. First, before that, let's create the node. Here, to create the node, I'll use new node is equal to node and the data past the data. We'll use underscore. So now new node is created. Next, let's see what happens if I add a new node after the given node. So first, let's take this as x. So now I need to add the new node after this node. So first step is I'll create the new node like this, 100 data. I'll take 100. Now here, n is also pointing here. After creating the new node, I need to change its previous reference and next reference. So for that first step is, I need to change this new node nref. I need to store 3,200 here. Right? It need to point here, where 3,200 is stored here. What is this? This is n n dot n reference n dot n reference. Okay. So now 3,200 will be stored here. After that, let's change the new node p reference. Here, what you need to store? You need to store this value 500. What is 500? That is n. So you need to take new node p ref is equal to n. So first create the new node and change its nref and prf. Next, now before changing this, we need to change this. This need to contain the previous node reference. That is nothing but this node, new node. It need to contain new node. Now what is this position? This is n. nref is 3,200. That is nothing but this is n dot n reference. This is its previous reference. So you need to take n dot nref.prf is equal to new node. That's why I told you before changing this, you need to change this. Here, this node is n. So n dot nref is 3,200. That is this node. So this node becomes n dot nref and in that node, this position is n dot nref.prf. That is equal to new node. So it will store new node link. That is 111. Next, you need to change this. That is n dot nref. This is n. That means this is n dot nref. You need to store new node here. So this is the code. But here, as I said, you need to be careful about one thing while inserting the new node after the given node. That is, you need to check whether you are inserting the new node after the last node. Let's see what will happen if I insert the new node after the last node. So I'll take this as x. So now x and n are pointing here. Okay, x and n is pointing here. Now I'll create the new node first, 200. Now initially, both the reference are pointing to none. Now what you need to do is you need to change the new node preference. That is this, you need to take as n. So it need to point here. So you need to take 3,200. So you need to follow this step. And next, you need to check the new node nref. That is, you need to take new node nref as n nref. So it will point to none. Next, you need to change this reference. It need to point to new node. So you need to take n dot nref is equal to new node. So now if you want to add the new node after the last node, then you need to write this code, this code, and this code, you don't want this line. That's why you need to be careful about inserting the new node after the last node. So to write this code, what I'll do is first, I'll take these two line. That is, I'll take new node nref is equal to new node prf equal to n. Next, here I'll take this condition. If n dot nref is not none, that is because I'll chuck if we are inserting the given node after the rest node, other than the last node, then you need to write this condition like this. If n dot nref is none, that means we are inserting the new node after the last node. That's why you need to take the condition like this. If n dot nref is not none. So here you can see, if this is the last node, then here you can see this is n dot nref, it is none. If it is not none means it is rest of the node, not the last node. If it is not none, then take n equal to nref dot prf equal to new node. If you are inserting the new node after the last node, this line is not necessary, right? That's why we are taking this condition. Lastly, nref is equal to new node. So now we are done. Here what I did is first I created the new node, we changed its nref and prf. Next I'll chuck whether we are inserting the new node after the last node or not. If we are not inserting the given node after the last node, then we need to include this line. If we are inserting the given node after the last node, this line is not necessary. Lastly, change n dot nref to new node. Next, let's write the method for add before. So I'll take add before, I'll take the method name as add before and here I'll take self data and x same parameters. And also here you need to let's copy this till here. The steps are same, right? We need to find out whether link list is empty. If it is not empty, then we need to go to the given position that is x and we need to check n is none. So this is same. So let's copy this. Here I explained you, right? So in the add before method also, you need to check dll is empty. If it is not empty, traverse to the given node x. So that's what we are doing here. We need to do the same thing here. Okay. Next here, if n is not none, that means we reached the x. Now we need to insert the new node before x, not after x before x. So if you are inserting the new node before x, then you need to be careful about whether you are inserting the new node before the first node. Okay, you need to be careful about only one thing that is you need to check whether you are inserting the new node before the first node. In the add after you need to check whether you are inserting the new node after the last node. Here in the add before method, you need to be careful about whether you are inserting the new node before the given node. In the else part first, we need to create the new node using node data. Next, let's see. So here, as I said, you need to be careful about two things. Whether you are adding the new node before the first node before rest node, that is second node, third node or the last node. So first, let's take this rest case. So if I want to add the new node before second node or third node or fourth node, what will happen? First step is you need to create the node like this, create a node in ref and pr if will point to none. So here, first you need to change n ref and pr of. So I'll take new node n ref equal to new node. pr of equal to first, I need to change these two. Now here, I'm adding the new node here before this node. So I'll take this as x. So n is also pointing to here now. In the new node, next link reference, I need to store 3200. 3200 is nothing but n now. So you need to take n here. And for new node pr if I need to store this node reference, that is I need to store 500 here. So 500 is stored here in the end dot previous reference. So you need to take n dot pr if done. Next here, in this position, I need to store the reference of new node to access this position. This is n. So this node becomes previous node of n. So this is n dot previous reference. And in that this is n dot previous reference dot n ref. So I need to take n dot pr if dot n ref is equal to new node. So to access this place, what I need to do is this is n now. So this is the previous node of the n. That is nothing but n dot pr if. And in that this position is n dot pr if dot n ref. So that is equal to new node. Lastly, you need to change this and that is n dot previous reference. So here you need to take n dot pr if is equal to new node. But I said in this method, we need to be careful about one thing that is we need to check whether we are inserting the new node before the first node. Let's see what will happen if I insert the new node before the first node. I'll create new node like this. Initially, it is pointing to none. Next, I'll check these statements one by one new node n ref equal to n. So this is new node n ref equal to n. So now this is x and this is n because we are inserting the new node before the first node. So this is x and x n. So n is 1000 10. So it will store 1000 10. So it will work properly. new node dot pr if equal to n dot pr if. So new node pr if equal to n dot pr if. So it is none. So it will store none here. That's also okay. So this is also working properly. Next, if I take n dot pre reference dot n ref n is this n dot pr if is none, none dot n ref. So that that time we'll get error. So we don't need this statement while inserting the new node before the first node. This is not required. Next statement is n dot pr if equal to new node. So n is this pr if is this new node. So it will store the link of the new node. It will point here. If it is 511, it will store that. If you are inserting the new node before the first node, this statement is not required. So let's write the condition here new node n ref is equal to n. And here you need to check n dot pr if is not none. That is nothing but we are checking whether we are inserting the new node before the first node or rest node before the rest node. If n dot pr if is none, that means we are inserting the new node before the first node. At that time, that line is not needed. If it is not, that means I this line is needed. That is this line n dot pr if n ref equal to new node. So we need to take n dot pr if dot n ref is equal to new node. And here outside this you need to take n dot pr if is equal to new node. And one more very important thing here, if you are adding the new node before the first node, then you need to point head here to the new node. So when you chuck here, if n dot pr if is not none, that means for the rest of the node, if n dot pr is none, that means we are inserting the new node before the first node. That's why here in the L-spart unit to take, if n dot pr if is none, that means self dot head should be new node. Okay. So now we are done. So let's add the new node after and before the given node. So here I'll take add begin as four and first, let's call add after and I'll add 10 after four. So let's execute this. And here you can see. Now if I want to add a new node after 10. So here I'll take 100 as the data and I'll add 10. Here you can see 100 is added after 10. Now if I take 1000 as the given node x and if I execute that 1000 is not present in the double-linked list. So we'll get given node is not present in the double-linked list message. Also if I try to insert for the empty, here we'll get this message. Linked list is empty. We are getting three message that's because of this print L and print L reverse. And next let's do before. So let's take before method. So here we have four, a single node in the double-linked list. I want to add 10 before four. So let's execute this. And here we can see 10 is added before four. This is for forward traversing. This is for backward traversing. And if I want to add this to empty, double-link, I'll get error like this. Okay. So in this way, you can write this add before and add after method. If you're comfortable with the add after and add before method of the single-linked list, then you can convert that method to work for double-linked list also. I'll show you the code for that. So here I have add after method based on the single-linked list add after method. I did few changes to this and we got this. Here we want check link list is empty or not. Like I explained in the add after method of the single-linked list. First, I'll check while n is not none. And I'll search for the x. If x is not present, I'll print this message. And here I'll take separate condition for last node. I'll check whether we are inserting the new node after the last node. If s then I'll write the separate condition. And in the else part, I'll write the separate condition. Here we have the condition when we insert the new node after the last node. And this is for the rest of the nodes. You can write the code like this also. You can analyze this code and if you have any doubt you can ask me. Next for add before also. Here we can see the code. We'll take link list is empty. This condition is for whether we are inserting the new node before the first node. I wrote the separate condition for that like this. So this also works. And if you have any doubt you can ask me. So that's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet you in next class till then take care.