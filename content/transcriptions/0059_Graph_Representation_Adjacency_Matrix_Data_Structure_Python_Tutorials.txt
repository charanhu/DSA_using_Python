 Hello guys and welcome to Amulea's Academy YouTube channel. We were discussing about graph data structure and next in this series let's talk about graph representation. That is how we can represent or store graphs in computer memory. Manually if I want to write a graph then I'll take a circle inside that will represent the data. These are called as nodes of the graph or vertices of the graph and the connection between the nodes is represented by the line. This line is called as edge. Manually we'll write the graph like this. But if I want to store this in the computer memory then how to do that? How to store this data and connection? I can't use circle and lines in the computer memory right? Then how to store graphs in computer memory? There are different ways to store the graph in computer memory. Of course we are not discussing all of them here. Here we'll discuss about the two most commonly used representation. That is adjacency matrix and adjacency list. Here we'll talk about the adjacency matrix. In the next tutorial we'll talk about adjacency list. First let's decode the name. Why it is named as adjacency matrix. Here what is adjacency means? In the previous tutorial while discussing about the terminologies of graph we discussed about adjacency node. If there is an edge from node u to node v then u is adjacent to v. u and v are the adjacent nodes. This adjacency will tell you about the connection between the nodes whether there is an edge between the nodes or not. Now what about the matrix? Matrix is a two dimensional array which contains row and column. This is a 2 by 2 matrix, 2 row and 2 column. This is a 3 by 2 matrix, 3 rows and 2 column. So in total an adjacency matrix is a matrix representation of exactly which nodes in a graph contains edges between them. Or in simple words we can say it will represent the connection between the nodes in the matrix form. Alright now we know what is adjacency matrix is. Next we'll see how to create the matrix. In this representation first we need to create k into k matrix. Here k is the number of nodes present in the graph. First we need to create a k into k matrix and in the matrix both the row and column represent the nodes of the graph. If there is an edge between any two nodes I'll store the value 1 and if there is no edge between the two nodes I'll store the value 0. So matrix will be filled with the zeros and ones. Also represents that there is no edge between the two nodes. One represents that there is an edge between the two nodes. Alright so let's take a few examples. Ok first here we have a graph. This is an undirected and unweighted graph. Now if I want to represent this graph using adjacency matrix then how to do that. So let's see that. The first step in this adjacency matrix representation is we need to create k into k matrix and k is nothing but the number of nodes present in this graph. So here 1, 2, 3, 4 and 5. This graph contains 5 nodes. So first we need to create 5 into 5 matrix. So let's create that. Here we have a 5 into 5 matrix. As I said both row and column of this matrix represent the nodes of the graph. So here I'll take first A, B, C, D, E in the row the nodes of the graph and here in the column also I'll take A, B, C, D, E. So both row and column will represent the nodes of the graph. And in this matrix we need to store 0 or 1. If there is an edge from a node to another node then I need to represent 1. If there is no edge from a node to another node then I need to represent 0. So first let's start from A to A. Let's check whether there is an edge from A to A. If an edge start from the same node and ends at the same node then that is called as self loop or self edge. Here we don't have that right. We don't have any edge from A to A. So that's why here I'll store 0. Next A to B here we can see there is an edge. So I'll store 1. A to C, yes there is an edge. A to D, yes there is an edge. A to E, no. There is no edge from A to E right. That's why 0. Next let's move on to the next row. B to A, yes here we can see. This is an undirected graph. So we have an edge from B to A also. So here 1. B to B, no. We don't have any self edge here. B to C, no. B to D, yes. B to E, yes. That's why store 1. Next move on to the next row. C to A, yes there is an edge. C to B, no. C to C, no. C to D, yes. C to E, no. Next D, D to A, yes. D to B, yes. D to C, yes. D to D, no. D to E, yes. Next E to A, no. E to B, yes. E to C, no. E to D, yes. E to E, no. So this is the adjacent semantics for this graph. So next let's take another example. Let's take a directed graph. Now first step in this representation is we need to create K into K matrix where K is the number of nodes present in the graph. So here 1, 2, 3, 4, 5, 6, 7. So first we need to create 7 by 7 matrix. So here we have 7 by 7 matrix. So you can take this in any order. So let's check whether there is an edge from A to A, no. A to B, yes. A to C, yes. A to D, no. A to E, no. A to F, no. A to G, no. Next from B to A, no. Because this is the directed graph. Here you can see there is an edge from A to B, but there is no edge from B to A. B to B, no. B to C, no. B to D, yes. B to E, yes. B to F, no. B to G, no. Next from C, C to A, no. C to B, no. C to C, no. C to D, no. C to E, no. C to F, no. C to G, no. Next from D. So D to A, no. D to B, no. D to C, no. D to D, no. D to E, no. D to F, no. D to G, no. Cool. Next E. From E to A, no. E to B, no. E to C, no. E to D, no. E to E, no. E to F, no. E to G, no. Next F. F to A, no. F to B, no. F to C, yes. F to D, no. F to E, no. F to F, no. F to G, yes. There is an edge. No. F to E, no. F to F, no. F to G, yes. There is an edge, right? Next from G. G to A, no. G to B, no. G to C, no. G to D, yes. Here, there is an edge. G to E, no. G to F, no. G to G, no. This is the adjacent symmetric. If there is an edge, you need to represent it as one. If there is no edge, you need to represent the value zero. And in the row and column, you need to take the nodes of the graph. All right. So this is about the directed graph and undirected graph. But what about the weighted graph? In the weighted graph, every edge will be associated with n value, right? Then how to represent that in the adjacent symmetric form? So let's take another example. Here we have a weighted graph. Let's see how to represent weighted graph using adjacency matrix. In unmeted graph, what we did is if there is an edge from a node to another node, we'll represent or we'll store the value one. In the weighted graph, what you need to do is if there is an edge from one node to another node, instead of storing one, you need to store the weight of that edge, cost of that edge. And rest everything is same. You need to create k into k matrix. k is nothing but the number of nodes present in the graph. So here this graph contains five nodes. So we created five into five matrix. Then here, write down the nodes. Then let's check whether there is an edge from a to a. No, so zero. Let's check from a to b. Yes, there is an edge from a to b. Now instead of storing one, we need to store the cost of that edge. That is 10. Next a to c, yes, so five store the cost a to d. There is an edge and cost is four. A to e, there is no edge, so store zero. Now b to a, 10, b to b, zero, b to c, zero, b to d, the cost is seven, b to e, three. Next c, c to a, cost is five. C to b, there is no edge. C to c, no. C to d, cost is one. C to e, there is no edge. D to a, cost is four. D to b, cost is seven. D to c, cost is one. D to d, zero. D to e, cost is two. Next a to a, zero, there is no edge. A to b, cost is three. A to c, there is no edge. A to d, cost is two. A to e, zero. This is the adjacency matrix. In the weighted graph, when there is an edge from a node to another node, instead of storing one, we need to store the weight or cost of that edge. I hope now you understood how to create the adjacency matrix for a given graph. And one of the interesting thing about this adjacency matrix representation is just by looking at the adjacency matrix, you can say whether the graph is directed or undirected. Also in some times you can say whether the graph is weighted or unweighted also. If the values on the both these sides of main diagonal of an adjacency matrix are same, then that matrix is symmetric and that symmetric matrix represent the undirected graph. For example, here you can see this matrix here in this adjacency matrix, the values on both the sides of the main diagonal is same. Here you can see, right? It is symmetric. By looking at this matrix, I can say this matrix is representing an undirected graph. In the directed graph, here we have, here you can see it is not symmetric. That's why I can say this is representing the directed graph. So when adjacency matrix is given, you can say whether that matrix is representing the directed graph or undirected graph. Here this is representing directed graph and this is representing an undirected graph. In the undirected graph, values of the both the side of the main diagonal is symmetric, is same. And by looking at the adjacency matrix, you can also say whether that graph is weighted or not, because in the weighted graph will represent cost of edge, right? But if the cost of all the edges of graph is one, at that time, I can't say whether that adjacency matrix is representing the weighted graph or not. But usually we'll have different cost for a different edge, right? In the weighted graph. So usually you can say whether an adjacency matrix is representing the weighted graph or not. Here you can see it is representing the weighted graph. Alright, so this is about the adjacency matrix. Here I want to implement graph using Python programming language, right? If I want to create adjacency matrix to store graph in Python, then I can use nested list for that. Here to create the matrix, I can use nested list. And also we can create a separate list to store the vertices or the nodes of the graph like this. A, B, C, D, E, a list. This will be start from 0 to 3, 4. Then to store this matrix, I can create a nested list like this. And here also index will start from 0. So in Python for the adjacency matrix, we can represent like this. For matrix, we can use nested list and we can take another list also to store the vertices or nodes of the graph like this. Here you can see the representation. Alright so this is about the adjacency matrix and in the next tutorial we will talk about the adjacency list. Why we have different graph representation? Why can't we just use adjacency matrix to store the graph? Why we need to study adjacency list also? That is because every method has its own advantage and disadvantage. Here adjacency matrix is easy to follow and represent. The adjacency matrix is representing the connection between the nodes whether there is a connection between the node or not. The question is this whether there is an edge between the nodes or not. The answer for this question is yes or no. But in the adjacency matrix what we are doing is we are storing the result for both the condition. If there is an edge between the node, we are storing the value 1. If there is no edge between the value, we are storing value 0 at that time. So we are representing or storing the result for both the cases. If there is an edge, we are storing some value. If there is no edge, then also we are storing some values. That is why we are using more memory space. If we are using the dense graph then it is ok because we do not have too many zeros in the adjacency matrix. That is why it is ok. But in this past graph we will have too many zeros and we are storing that zeros in the memory. Here we are wasting the memory. A graph in which the number of edges is close to the maximal number of edges is called as dense graph and the opposite. A graph with only few edges is called as sparse graph. Here this is a sparse graph and this is the dense graph. And here we can see we have adjacency matrix for this graph. Here in this adjacency matrix we can see lots of zeros. That means we are storing this adjacency matrix in memory and in that in the most of the places we are storing the value 0. It is ok with the dense graph because here we can see less number of zeros. But here you can see more number of zeros and we are storing that in the memory. We are using the memory to store zeros. In that cases we can use the adjacency list. Now we can store the graph using adjacency list. That we will see in the next tutorial. Ok so that is it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet you in the next class. Take care and be safe.