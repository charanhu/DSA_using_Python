 Hello guys and welcome to Amuleus Academy YouTube channel. In the previous tutorial we wrote a function for Graph traversal operation using DFS algorithm but we wrote that function using recursion. Today we will write that function that is the function for Graph traversal operation using DFS algorithm using iterative approach. Today we will implement DFS algorithm using iterative approach and here also to represent graph values adjacency list. That means in the program we will use dictionary to store nodes and adjacent nodes of the graph. So here we have a program. In this program we have add node function add edge function and here you can see DFS function. Here we wrote this function using recursion. Here you can see this function contains function call to itself and here you can see visited set as well as graph dictionary and here we are calling add node and add edge function. Later we are calling DFS function to perform traversal operation on the graph using DFS algorithm. Alright so today we want to write this DFS function using iterative approach. So for that first I will comment this. Here in this function we used recursive approach right and also I will comment all the statements related to this function that is this visited set as well as here you can see the function call. I will comment this. Next we need to define iterative function for DFS algorithm. So here I will take DFS followed by DFS and I will give the function name as DFS iterative and here I need to mention the parameter. So in DFS algorithm first we need starting node right. We need to know from where to start the traversal operation and in the DFS algorithm we can choose any node of the graph as the starting node. So while writing the function we will ask the user to choose the starting node and when we call the DFS function we will mention the starting node. That is why the first parameter will be the starting node like we did in the recursive function. Next here we can see in the recursive function we took the second parameter as visited set. This set will contain all the nodes which are already visited and while writing the function using recursion we need to define this set outside the function and we need to pass that as the parameter. But here we are writing this function using iterative approach right. That is why you can define this visited set inside the function. If you want you can define that outside also. If you define the visited set outside the function then also it is okay or if you want you can define that visited set inside the function also. Because here we are writing this function using iterative approach. That is why when I define a set like this visited inside the function this statement will be executed only once. Because we are not calling this function again and again. In the recursive function we will call this function again and again. That means when I call this recursive function once this function contains the function called to itself. That is why it will execute this statement or function body again and again. But here when I call DFS iterative function like this it will execute this statement only once. That is what we want here right. Here visited is a set which will contain all the visited nodes of the graph. And after creating this set we do not want to reset this again and again okay. That is why in the recursive approach we define that outside the function. But here we are writing this function using iterative approach. That is why you can define this inside the function. And if you are getting confused when to define this visited set outside the function and inside the function then don't worry define this outside the function. It will also work in the iterative function. Fine. So next here we are performing this traversal operation on graph. That is why we need to pass graph also like this. And if you are defining this visited set outside the function then you need to pass visited set also here okay. Next like we did in the recursive approach in the recursive function first let's check whether they mentioned node or the given node. The starting node is present in the graph. If it is not present in the graph that means we can't start the traversal operation from that node right. So first step is here you'll check if node not in graph. If node is not present in the graph then we can't do anything right. That's why we need to check this condition and we'll print this message. That is node is not present in the graph and we'll use return that is come out of the function. And if this condition becomes false that means node is present in the graph. The mentioned node starting node is present in the graph. Then what I need to do I need to perform the traversal operation using TFS algorithm. And here I want to do that using iterative approach. So for that to implement DFS algorithm using iterative approach we'll use start data structure. And I already made a video on that how to implement DFS algorithm using stack data structure. So I will give you the link of that video in the description box. So if we are using stack data structure to implement DFS algorithm what we need to do is first we need to choose the starting node and we know while calling this function we'll mention the starting node. Then what you need to do you need to push that starting node to stack. Push starting node to stack right. For example if I take A as the starting node I need to push that to stack. Push stack. Next what you need to do you need to pop the element from the stack. So we'll pop the starting node because only one node is present in the stack. So we need to pop that. First push the starting node to stack. Next you need to pop that. It will remove the topmost element from the stack. So the starting node will be removed from the stack like this A. Next what we need to do I need to check whether A is already visited. So to do that we have visited set. So I need to check whether A that is the popped element. So popped element is present in the visited set. If it is not present then only I need to visit that right. If it is not then visit that that means print that and we need to add that to set. We need to mark that node as visited. First let's write the code for these steps. First what we need to do we need to choose the starting node that is already done. When we call this DFS iterative we'll mention the starting node. Next what we need to do we need to push that starting node to stack. And here I'll use list as stack. So here first I'll create a empty list called stack. It is a empty list now. Next push the starting node to stack. So I'll perform stack dot append. I'll append the starting node to stack. Okay here I'll push the node like this. Append means it will add the element at the end right. Next what I need to do I need to pop the starting node right. First I need to push the starting node. Next step is I need to pop the starting node. So for that I'll use pop method the list method pop which will work like this which will remove the last element present in the list. So here stack dot pop I need to use stack dot pop what it will do is it will remove the last element present in the list or we can say stack here. And this pop method will return the removed or popped element okay it will return the removed element. So I'll take a variable and I'll store that current equal to like this. So here after removing the element from this stack like this we need this element right we need to chuck whether this node is already visited for that we need that. That's why here I'll take a variable and I'll store that. Next what I need to do I need to chuck this now this is the popped element I need to chuck whether this is already visited. For that I'll use if condition I'll chuck if current okay that is the popped element not in visited. So here visited will contain all the nodes which are already visited. So I'll chuck whether current that is the node which I popped now recently which is present and visited. If it is not present and visited then only I need to print that node that means I need to visit that node right. So print current like this and also I need to mark that node as visited now. We printed that node that means we visited that node. So next I need to mark that node as visited for that I need to add that to visited set. So visited add current right. Now we wrote the condition or I can say code for these steps. Next what I need to do I need to get all the adjacent node of the popped element right. So here after visiting a what I need to do I need to push all the adjacent node of a to stack. For that first I need to get all the adjacent node of a that is the starting node. So how to get the adjacent node of starting node or any other node. Here we represented using dictionary and in this dictionary every node of the graph is represented as key and the adjacent node of that key is represented as value right. Here we can see list of nodes. These are the adjacent nodes of a, a is adjacent to b, c, d. So if I want to get the adjacent node of starting node for example a then what I need to do I need to get the value of a value of key a and also I want to get the value one by one that's why I'll use a loop here. I'll use like this for I in graph of current and what I need to do I need to push this in node to stack. So stack dot append and push that to stack. Next a is marked as visited. Next here we need to get all the adjacent node of a. Here adjacent node of a is b, c, d. You can push it in any order. Here in our program it will push according to this it will first push b next to c next to d because we stored the value like that right that's why first b will be appended c and d. Next we need to pop the element. Next we need to perform the pop operation right we need to pop the top most element that is we need to perform this operation pop then what I need to do I need to check whether the pop element for example here d I need to pop that and I need to check whether that element is visited that is I need to perform this operation. And if it is not visited then I need to visit that node and I need to mark that node as visited and I need to check the adjacent node of D and I need to push that to stack. So we need to perform this operation again now. I need to repeat this step for next element now and we need to repeat that until stack becomes empty. We need to do this again and again until stack becomes empty. Okay, that's why what I'll do is I'll include this inside a loop and here I'll cut this and here I'll use a while loop I'll use while stack when stack becomes empty this condition becomes false until stack contains element we need to perform this that is I need to pop the element. Next I need to check whether that element is already visited if it is not visited then you need to print the element and add that to current and get the adjacent node of that and append that to list. All right, so now we are done. So let's see how it works. So here I'll call DFS iterative and I'll take A as the starting node we don't want visited and graph. Okay, let's execute this. Here you can see ADEBC. If you observe this code closely then you can see stack can contain duplicate values. If you want to avoid that you can include a condition here and if you have any doubt about the working of this function then don't worry. In the next tutorial we'll see the working of this function with an example. So that's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet you in next class till then take care and be safe.