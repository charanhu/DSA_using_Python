 Hello guys and welcome to Amulya's Academy YouTube channel. We were discussing about binary search tree implementation using Python programming language. And in the previous tutorial we wrote a method for insertion operation. Because till now we didn't wrote any method for the traversal operation. So I can't show you the output here. So that's why today in this tutorial I'll explain you how this insert method works line by line. So here in this Python program we have class BST. And the execution of the program begins here. We are creating an object from this BST class. The object name is root and here I am passing the data or the value of the node as none. So what it will do is it will create an object. So here we have this program. Here we can say root BST none. So it will create a node here or object you can say and I'm giving the name as root here. So root and here we can see I'm passing none. So here the key of object will be none. When I create an object from the BST class by default the initialization method will be called. So it will initialize key, l child and r child of the root. So here self is nothing but the root object. So root dot key will be none. Root dot l child will be none. This is the default value and root dot r child is none. After executing this line will get an object root with key as none, l child as none, r child as none. Next it will execute next line root dot insert 20. Here we can see we are calling the insert method and here object name is root and the data of the new node is 20. So when I call this method name so this method body will be executed. So here data will be 20 and self is nothing but root the object itself. So root. So it will execute this body now if self dot key is none. So as I said self is nothing but root now root dot key is this and it is none because here we passed none. That's why root dot key is none. If nodes key is none then I'll treat that node is not present. Node is empty. I won't consider that node. That's why even though we have an object here root object, I'm considering this tree as none now because its key is none. That's why here I'll check self dot key is none. So root dot key is none. This condition becomes true. So I'll take self dot key is equal to data root dot key is equal to data. So here I'll change its key and here I'll store 20. Now a node is created with the key as 20 left child as none or child as none. Now our tree contains one node after executing that it will execute return statement. So it will come out of this method and control goes back to where it is called. So it will come back here. We don't have any other instruction or statement to execute. That's why stop the execution of this program. So we'll get a node a single node in the tree. All right. In this way this program works. This is a case if you take the data or value as none while creating the node or object. Okay. This is the one scenario and the next scenario is so here I'll take down the entire program. Let's see how this program works. So this is the class definition execution of the program will begin from here root BST 10. So here I'm creating an object or node with value as 10. So first node will be created with value as 10. Its name is root and here it is none and none. So this is left child and this is right child. If I take root dot key that is 10 root dot left child none root dot our child is none. So while creating the object it will call the initialization method. So we'll get a node like this. After that here we can see list one equal to some values and next we have loop for I in list one as we know I value will be first 20 next four next 30 like that. Root dot insert I. Okay. So it will insert the value one by one. So now when it will see root dot insert I initially I value will be 20. So it is like root dot insert 20. So we are calling this insert method for value 20. So here data will be 20 self is nothing but root. So it will execute this loop body if self dot key is none root dot key is none. As I said root dot key is here 10. It is not none. So this condition become false. So it won't execute this if body control will come here and it will execute this if self dot key is equal to equal to data self dot key is 10 and data is 20 both are not equal. Here we are checking for the duplicate value and it is not the duplicate value. So it won't execute this if body also control will come here if self dot key is greater than data. Now self dot key is 10 and data is 20 here 10 is not greater than 20. So this condition become false. That means the new node need to be present in the right side of the root node because its data is greater than the root node data 20 is greater than 10. So this condition fails. So it won't execute if body it will come here in the else part. It will check if self dot our child. So here self dot our child is nothing but root dot our child. It is none. So here we'll get condition like this if none. So none is nothing but no value. So it is false. So this is treated as false. This is like if false. So here this condition is false. So it won't execute if body. So it will go to else part here because self dot our child that is root doesn't have to write child. So it will execute else part here self dot our child equal to BSD data. So self dot our child is here. We are changing its value. So it is equal to BSD data. So BSD is the class name and I'm passing data. That is nothing but we are creating an object. So when I take BSD data, I'm creating an object here and its address will be stored here. For example, I'll take 4101 its address new object address. So it will be stored here because I took self dot our child equal to right. So this is self dot our child and whenever we'll create an object from this BSD class, this three fields are initialized automatically. So self dot key becomes key here BSD data data is 20. So here we'll get 20 and it will be none and this will be none. Okay, node is added like this to the tree. Now this execution is done and we don't have any other instruction to execute here after this. So it will come out of the insert method and control go back to here where it is called. So here root dot insert 20 is done. So again control will go here and now I value becomes the next value of list one that is 4. Now again this instruction will be executed for 4. So it is like root dot insert 4. So we are again calling this insert method for value 4. So control will again go here. The insert method. So here data is 4. Self is root because I'm calling root dot insert right. So self is root. So first it will check self dot key is none. Road dot key is not none. So it won't execute this. It will execute this condition now if self dot key is equal to data. So check for the duplicate value. So self dot key is this 10. 10 is not equal to 4. So it won't execute this body. It will come here. If self dot key is greater than data. Now self dot key is 10 and 4 is smaller here. This condition becomes true right. So next it will check if self dot L child. No here self dot L child is none. Okay. Root dot L child is none. So this condition fails. So it will go here self dot L child equal to BSD data. Data is 4 here. It will create another object and here instead of none. It will store the address of this new node and it will be none. And this will be none. Why that is because when I call BSD data. So it will create an object and this method is called atomically. So it will initialize these three fields. So key is for L child is none. R child is none. So we'll get node like this. So now it won't execute else part because if condition was true. So it will come out of this and again control will come here. So now root dot insert for four is done. So next the for loop will execute for the next value. So 30. So we are calling root dot insert 30 here. So now again this will execute and now data is 30 and self is nothing but root. So self dot key is none. No. So self dot key is equal to equal to data. No. Here data is 30 and self dot key is 10. That's why next it will check if self dot key is greater than data. So data is 30 self dot key is 10. 10 is not greater than 30. Right. So this fails. So here we'll go here self dot R child. I'll check. Yes. Self dot R child. It is present now. It contains a node. It has some address stored here. So this condition becomes true now. Okay. Self dot R child. It contains some value. So it is true. That means root node have a right child. So what it will do is it will execute this self dot R child dot insert data. Now what will happen is here we can see a recursive call. So self that is root R child dot insert data is 30. Now what we are doing is we are calling this insert method for self dot R child. Now this execution will be paused and this insert method will work for this now. This function call first. So here data will be 30 but self is nothing but self dot R child. Self dot R child is self now here. What I was told here that means this node. So here now this is self. So now if I check self dot key is none we are checking for this node now. So here 20 is not none. So this condition fails next. It will check if self dot key is equal to equal to data. Data is 30 and self dot key is 20. No next it will check whether self dot key is greater than data. Self dot key is 20 data is 30. So no. So it will execute else part and it will check if self dot R child here self dot R child is none. So this condition fails. So it will execute else part self dot R child equal to BST node. So it will create a node here with data as 30 and here will none none. And if I take it as 70000 that will be stored here. Now the execution of this function is done. Okay, it will execute it will create the node. Now we don't have any more statement to execute. So it is done after that. So control will come back to here this function body whatever paused here. It will play now. So this is done after that we don't have any other statement to execute. So this is done control will again come back to here. Now root dot insert will be executed for the another value of list one that is four. Now here we are calling root dot insert for four. So now again control will go here. Now here value is four. Theta is four self is root now because here root dot insert just to see the object name before the method name. So you will understand what is self. So self dot key is none. No, it is 10. So it fails self dot key is equal to equal to data. No, here it is 10 and key we want to enter is four. So no, if self dot key is greater than data, yes, here four and 10. So 10 is greater. This is greater. So I need to place that in the left side. So if self dot L child, yes, L child is present here. All right. So we need to call self dot L child dot insert data. So here we can see another function call to this function itself. So that's why it will pause this and it will execute this function body for this value now. Okay. Self dot L child dot insert four. So now this will be paused and self dot L child dot insert for four will be executed first. So this will be executed for this now, this function call. So this is self now here. Self is nothing but this self dot L child here you can see, right? And data is four. If self dot key is none here, it is four not none. So it won't execute this. If self dot key is equal to equal to data, yes, here we can see we want to insert four and self dot key is also four. Right. So it will execute return. So it won't execute any new node to tree. It will ignore the duplicate value. So so control will come back to this method where self is root. Okay. And we don't have any other statement to execute. So it will stop this and it will come back to here. Next route dot insert will be executed for next value one next, five next six. Okay. In this way, this program works. When we call root dot insert at that time, self value will be root. If I call root dot L child dot insert, root dot L child will be self. Okay. You just need to remember that and I know I didn't explain all the values here. It is incomplete. So I want you to complete that just trace this program. If you have any doubt, you can come back to me. You can ask your queries in the comment section after inserting six to the tree. So for loop will complete its execution. So it will stop the execution of the program. All right. So this is about the insertion operation in binary search tree. So that's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet in next class till then take care.