 Hello guys and welcome to Amulea's Academy YouTube channel. We were discussing graph traversal operation and in the previous tutorial we saw how we can traverse a graph using DFS algorithm. Next, let's talk about DFS implementation. We can implement DFS algorithm using recursive approach or iterative approach. That is, we can write a function for DFS algorithm recursively or using iterative approach. But in both recursive and iterative approach, we will use stack data structure to implement DFS algorithm. In iterative approach, we will use stack explicitly or externally and in recursive approach, stacks are used internally. In the next tutorial, we will see how to write the function for DFS algorithm using recursive approach and iterative approach. Today we will see how and why stack data structures are used to implement DFS algorithm. Alright, first let's answer the first question. That is, how stack data structures are used in DFS algorithm. Okay, so first step is we need to choose this starting node. And here I'll choose this a as the starting node. Okay, this is my starting node. So I need to start the traversal operation from here. And here after choosing the starting node, I need to push that starting node to stack. Okay, stack follows last in first out or first in last out rule. And in stack push operation means inserting the element to the stack. Pop operation means removing the element from the stack. Right. So now first unit to perform the push operation, that is you need to push starting node. So here starting node is a. So here I'll create a stack like this. And I need to push a. So now a stack contains a. Next step is after performing push operation, we need to perform pop operation. Now perform pop operation. Pop will remove the top element present in the stack. The element which is present in the top, it will remove that. Here only one element is present in the stack. So it will pop that. So here pop a. Now a is removed from the stack. After that you need to chuck whether a is already visited. Here no a is not visited. So visit that node. First you need to pick the starting node and you need to push that to stack. Then you need to perform the pop operation. That means we are removing the starting node from the stack. And we need to chuck whether that node is already visited. If it is not visited, then visit that node. So now a is visited. Now next step is you need to push all the adjacent node of the starting node to stack. After visiting a you need to push all the unvisited adjacent node of starting node. Here a is the starting node and its adjacent node is b which is unvisited. So I need to push that to stack. Push unvisited adjacent node of the starting node. Now after push what you need to do? You need to perform pop operation. That means pop the element from the stack. So here in the stack only one element is present. So pop b. Now b is popped out from the stack. Now what I need to do? I need to chuck whether b is already visited. Here b is not visited. So you can maintain list or array which contains the nodes which are already visited. For example here like this visited list. Here a is visited. So like this. Now here we need to chuck whether b is visited or not. Here b is not visited. So visit that. That means add that here also. Now next step is b is visited. Now what you need to do is you need to push all the unvisited adjacent node of b to stack. Here c is the adjacent node of b and it is unvisited. So push that to stack. After push operation you need to perform pop operation. So here only one element present in the stack. So pop c. Now chuck whether c is already visited. No. So now visit that and also add this to this list. Now c is visited. Next what you need to do? You need to push all the unvisited adjacent node of c to stack. Here d, e, b are the adjacent node of c. b is already visited. So you need to push d and e to the stack. And you can push in any order. Okay. You can push first d next e or you can push first e next d. Here first I'll push d next e. Now there are two elements present in this stack. Now after push operation what do you need to do? You need to perform pop operation. Pop operation is nothing but removing the top element from this stack. So in the top e is present. So pop that. Remove that. Now next step is you need to chuck whether e is already visited. No. So that means visit that node. So here visit that node. Here also add this here. Now pop operation is done. We visited node e. Next what you need to do? You need to push all the unvisited adjacent node of e to stack. Here c and f are the adjacent node of e. c is already visited. So I need to push f here. After push operation what you need to do? You need to do pop operation right? Pop operation means removing the element present in the top. So you need to pop f here. Remove f from this stack. So next you need to chuck whether f is already visited. No. So visit that and also add that here. Now f is also visited. Previously we did pop operation. Now we need to do the push operation. If we visited next we need to push all the unvisited adjacent node of f to stack. e is the adjacent node of f and it is already visited. We don't have any other node to visit here. We read the dead end. There is nothing to push here. Now next we need to perform the pop operation. Here only one element present in this stack. So pop that. Pop d. So next chuck whether d is already visited. No. So visit that. Here what we are doing is first we choose this as the starting node. We visited b c e f. We read the dead end. So what we need to do we need to backtrack right? We will come here. We will chuck whether this node contains any adjacent node to visit. No. We will come here. Next we will visit d. That's what we are doing here. We are visiting d now. So I will visit d. Now what you need to do? You need to push all the unvisited adjacent node of d to stack. After performing pop operation you need to push. Here yum and k are the unvisited adjacent node of d. So I will push that to the stack. And for now the order of nodes doesn't matter. Now after push operation what you need to do? You need to do pop operation. So pop k. Remove k. Chuck whether k is already visited. No. So add that to visited node and visit that. Next you need to push the unvisited adjacent node of k to stack. But we don't have anything to insert right? We don't have any value to push. So what do you need to do? You need to do pop operation next. So here yum is in the top. So you need to pop that pop yum and chuck whether it is already visited. No. So visit that. Next push all the adjacent node of yum to stack. But here we can see we don't have any unvisited adjacent node of m. That's why there is nothing to push. Then we need to perform pop operation. But here we can see stack is empty. So we can't perform pop operation. That means we are done. So now you can see right how stack is used to implement DFS algorithm. So let's take another example. Okay here we have another graph. I'll take stack. So let's take a as the starting node. So first step is I need to push the starting node to the stack. After performing push operation you need to perform pop operation. That means pop a. Next step is you need to chuck whether a is already visited. So I'll take a list of visited nodes. And here you can see it is initially empty. That means a is not visited. So mark this node as visited and visit that node. Now what do you need to do? You need to push all the unvisited adjacent node of a to stack. Here C, B, D are the adjacent node of a and these nodes are unvisited. So here you can push it in any order and push like the C, B, D. So next what you need to do after push operation you need to perform pop operation. In the pop operation we need to remove the top element from the stack. So pop D. Chuck whether D is already visited. No then mark it as visited and visit that node. Then next what you need to do? You need to push all the unvisited adjacent node of D to stack. So here D is adjacent to C, B, A, E in which A is already visited. So you need to push C, B, E to stack C, B, E. You can follow any order. Okay. And you can push the nodes in any order. So now here you can see stack contains duplicate values. So in DFS algorithms stack may contain duplicate values. Right. Next after push operation what do you need to do? You need to do pop operation. So pop E which is in the top. So E, Chuck whether E is already visited. No. Okay. So mark it as visited and visit that node. So now E is visited. Next what you need to do? You need to push all the unvisited adjacent node of E to stack. Only B is unvisited. D is already visited. So push B. After push operation what you need to do? You need to do pop. So pop B. So Chuck whether B is already visited. No. So mark it as visited and visit that. Next what you need to do? You need to push all the unvisited adjacent node of B to stack. Here A is already visited. D is already visited. E is already visited. All the adjacent node of B is visited. So we don't have anything to push. Next you need to do is pop operation. So pop B. Chuck whether B is already visited. Yes. So no need to visit that again. So skip this. Next pop C. C is already visited. No. Okay. So we need to visit that. So add this as marked and visit that. Now. Next push all the unvisited adjacent node of C. We don't have anything to push. Okay. Here you can see all the adjacent node of C is visited. So pop from the stack now. So we are popping B. So B is already visited. So skip that. Next again pop C is already visited. Here you can see. So skip that. Now here you can see stack is empty. So we are done. So when you pop a node from the stack and if that node is already visited, then you need to skip that. Okay. So this is how we can use stack in DFS algorithm. Now we know how stack data structure is used in DFS algorithm. Now the next question is why stack data structure? Why stack data structure is used to implement DFS algorithm? That is because here which node I want to visit that is actually depends on first in last out concept. That's why we are using stack. I'll tell you why. First here will be visit A next B next to C. Right. After that we have two way. Either we can visit D or E. If I choose D, then after visiting D, what I need to do is I need to visit M or K after completing this, we need to visit E. Okay. Here we need first in last out approach or last in first out approach. That's why here stacks are used. When I pop D, that means we are visiting D. After that what I need to do, I need to add M and K. Right. Here I'll add M K after visiting these nodes, then only we'll visit E. Whatever the node which we added first, that will be removed last. That will be visited last. Okay. So this is about the DFS implementation using stack. And in the next tutorial, write the function for DFS algorithm using recursive approach as well as iterative approach. So that's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet you in next class. Till then take care and be safe.