 Hello guys and welcome to Amalia's Academy YouTube channel. We were discussing about binary search tree and in the previous tutorial we discussed about its definition and how to construct a binary search tree when list of values are given. Next in this series we will discuss about the operations of binary search tree. We will discuss the different operations that are performed on binary search tree and all these binary search operations require comparisons to be made between the nodes. So the first operation which we are discussing here is searching for a node in a binary search tree. The search operation used to find whether a given node is present in the binary search tree or not. The searching process begins from the root node. First it will chuck whether binary search tree is empty or not. If binary search tree is empty then that means the given value is not present in the BST. Because binary search tree is empty it does not contain any node that means the given value is also not present. If it is not empty then it will compare the value of the root node with the given value. If it is equal that means the given value is present in the BST. So next step is you need to chuck root node value and given value. If S then the given value is present. If it is not if it does not match with the value of the root node. If given value is not equal to the key or value of root node then chuck whether given value is less than root node. GB is nothing but given value is less than root node value. If S then you need to search left sub tree. If the given value is smaller than the root node that is nothing but if given value is present in the binary search tree it need to be present in the left side of the root node. So you need to search the left sub tree. If it is not if this condition is false that means the given value is greater than the root node. So you need to search in the right sub tree. You need to search the value in the right side of the root node in the right sub tree and you need to perform this search operation recursively. That is if the given value is less than root node in the left sub tree you need to start from the root node of that left sub tree. You need to chuck this conditions again you need to chuck whether that is empty or not. If it is not empty then you need to chuck the value of that root of left sub tree and given value whether it is equal. If it is equal the value is present otherwise you need to chuck these two conditions. Given value is less than the root node of the left sub tree like that. You need to perform this operation again and again until you will get the given value or search is completed. If it is confusing don't worry let's take an example. So here we have a binary search tree. Here you can see the key or values of all the nodes. Now if I want to search 12 in this binary search tree I need to chuck the value 12 is present in the binary search tree or not. So for that first step is you need to chuck whether binary search tree is empty or not. It is not empty here you can see nodes right. So then you need to chuck the given value that is 12 with the key of the root node. Here this is the root node. Here the key of root node is 21. 21 is equal to equal to 12. No it is not right. 21 is not equal to 12. So next you need to chuck whether 12 is less than 21. You need to chuck this condition whether 12 is less than 21. We need to do this comparison because we need to see whether the given value is greater than the root node or less than the root node. If it is greater than the root node value then we need to search for that key in the right side right. We know how binary search tree is ordered. If the entered value or given value is less than the key of the root node then we need to search for that key in the left side of that root node. So that's why we are doing this comparison. We are checking whether 12 is less than 21. Here yes that means the given value is smaller than the key of the root node and if it is present in the binary search tree then it need to be present in the left side of the root node in the left subtree. So no need to chuck for the right subtree. We need to concentrate only on the left subtree now. So now what I'll do this condition becomes true. So we'll go to the left subtree and now this is the left subtree and this is the root node of the left subtree. So first here we need to compare the value 10 with 12 whether it is equal. 10 is not equal to 12 that means this is not the node we are searching. So next I need to compare whether 12 that is a given value is less than 10. No right it is not less than 10 it is greater than 10 that means I need to search for the key in the right side of this node. First we need to chuck the given value with the key of the node. If it is equal that means we found the key. If it is not equal then we need to chuck whether we need to search in the left side or right side. So for that we need to compare the nodes key with the given value and here we are comparing 10 with 12. 12 is greater than 10 so it need to be present at the right side of this 10. So here we'll come here and we'll compare 12 with the given value. It is 12 is equal to 12 that means we found the key while it is present in the binary search tree. So search is successful. I'll take another example. I'll take the given value as 11. I need to search 11 whether 11 is present in the binary search tree or not. So here let's start from the root node and we need to compare the value of the root node. Here we can see binary search tree is not empty so let's compare the key of the root node with the value. 21 is equal to 11. No it is false. Then we need to chuck whether 11 is less than 21. You can check for greater than also. It depends on you. Here first I'll check whether 11 is less than 21. Yes right 11 is less than 21. So given value is less than the key of the root node. That means I need to search in the left sub tree of the root node. So I'll come here and I'll check whether 11 is equal to 10. No it is not. Then I'll check whether 11 is less than 10. No it is not. That means it need to be present in the right side of the 10. If that node is present it should be present in the right side. So here I'll come here and I'll compare 12 with 11. Whether 11 is equal to 12. No right 11 is not equal to 12. And then I'll compare whether 11 is less than 12. Yes 11 is less than 12. That means it need to be present in the left side of the 12. But here we can see this node doesn't have any child node. It is a leaf node. That means 11 is not present in this binary search tree. So in this way you can search for a value or key in the binary search tree. Okay so this is about the search operation. And the second operation of binary search tree is insertion. The insertion operation or insert operation is used to add a new node with the given value at the correct position in the binary search tree. We need to add the new node with the given value at the correct position. Correct position is very important here. Adding the node at the correct position means that the new node should not violate the properties of binary search tree. So we need to insert the new node in such a way that all the nodes need to follow the binary search tree rule. So to insert the new node with the value first we need to chuck whether binary search tree is empty. If it is empty then just add the new node to tree. That will become the root node of the tree. No need to chuck its position at all because binary search tree is completely empty. So this is the first node we are inserting. So just add that new node insert that new node to tree. And next if binary search tree is not empty then we need to compare the value of new node and the value of the root node. And if it is equal then that means we are adding the duplicate value and how to deal with the duplicate values in the binary search tree. About that we discussed in the previous tutorial and it is entirely depends on you how will you treat the duplicate value. And if you don't want duplicate values in the binary search tree then also you can print a message for that. Here let's not talk about that for now. So here what I'll do is I'll do different comparison. I'll chuck whether the key of the root node is less than new node. So we need to compare the key of the root node with the new node whether it is less than or greater than the new node. If the new node key is greater than root node then we need to go to the right side and we need to insert that. If the key of the root node is greater than the new node then we need to go to the left subtree. We need to insert that new node in the left subtree. And in the right and left subtree also, we need to to compare the values of the new node and the values of the nodes again and again. Based on that comparison result, we will get to know in which side we need to place the new node. Alright, so let's take an example and we will see how this actually works. Now here I take a node with value 120. I want to insert this new node to this binary search tree. For that first I need to check whether binary search tree is empty or not. Here it is present, a tree is present with few nodes, that means this is not empty. So next I need to compare the root node key, that is 21, with the value of the new node, that is 120. I need to check whether I need to place this node in the left side of this node or right side of this node. For now just ignore the duplicate values, okay. I will just take that we are dealing with the distinct values. So here I will check whether the key of the root node is less than the key of the or value of the new node. So I will check whether 21 is less than 120. Yes, of course 21 is less than 120. So that means the key of the new node is greater than the root node. So we need to place the new node in the right side of the root node. So now need to check for the left sub tree, we need to concentrate on the right sub tree, we need to place the new node in the right side of the root node. So we will go to the right side of the root node and we will check. This is the first node in the right sub tree, right. This is the root node of the right sub tree. Just compare the value of this node with the value of new node. Whether 30 is less than 120 or you can check in reverse also whether 30 is greater than 120. We are doing this comparison to chuck where we need to place the new node to identify the correct position of the new node. So 30 is less than 120 of course, right. So that means 120. The new node has key which is greater than the this node. That means new node need to be present in the right side of the this node. So we will come here in the right side we have this node with key 100. So we will compare these two now. Whether 100 is less than 120. Yes. So the new node has key which is greater than this node. That means the new node need to be present in the right side of this node. And here in this right side we don't have any node. So you can insert 120 here. So to insert the new node first we need to identify the correct position of the new node. And for that we need to compare the values of the nodes present in the tree and the new node. So this is about the insertion operation and search operation. In both this operation one thing is common that is comparison. And here while explaining about the insertion operation I took the example of distinct value. Okay. So that's it for now. In the next tutorial we will continue the discussion on the operation of binary search tree. So thank you for watching. Don't forget to subscribe to my channel. I will meet you in next class. Till then take care.