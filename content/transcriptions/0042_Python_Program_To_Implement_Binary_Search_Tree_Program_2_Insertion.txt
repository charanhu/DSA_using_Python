 Hello guys and welcome to Amulya's Academy YouTube channel. We are discussing about implementation of binary search tree using Python programming language and in the previous tutorial we created a class called BST and in that we took initialization method. Whenever we will create a node, every node is an object here. So whenever we will create a node, the three fields of that node will be initialized key, l child and r child and while creating an object or a node, we need to mention the data of that node. And today in this tutorial we will write a method to perform insertion operation. While performing the insertion operation, we need to chuck different conditions or scenario. In that first scenario or condition is we need to chuck whether we are inserting the new node to the empty tree. That is before inserting the node, we need to chuck whether tree is empty or not. The first condition is this. So from this we can get two outcome that is s or no, either tree is empty or non-empty, right? If tree is empty, that means the node which we are adding will be the first node of that tree. If tree is completely empty and if I am inserting a new node, then that will be the first node of that tree. So if this condition is true, if tree is empty, then the node which we are inserting will be the first node of that tree. If it is not, if tree is not empty, that means tree contains one or more than one nodes. So at that time we need to find the position of the new node. We want to insert the new node to the tree, right? So first we will chuck whether tree is empty or not. If tree is empty, then the new node will be the first node. If tree is not empty, that means tree contains one or more than one node. At that time I need to find the position of the new node where I need to place the new node. Because binary search tree is a binary tree, either we need to place the new node in the left subtree or right subtree, so here the position of the new node is nothing but either we need to place the new node in the left subtree or right subtree. So next, we need to chuck the condition for this, whether we need to place the new node in the left subtree. If s, we need to place that. If not, then I need to chuck for the right subtree condition and I need to place the node in the right subtree. Alright, we need to be careful about these scenarios while inserting the new node to the tree. And also lastly we need to discuss about duplicate values. How to deal with the duplicate values? Either you can ignore the duplicate values in the tree or you can place that in the left subtree or you can place that in the right subtree. I made a separate video on how to deal with the duplicate values. I will give you the link of that video in the description box. You can go and check that. I will discuss about how to deal with the duplicate values at the end of this tutorial. Alright, so this is about few scenarios of insertion operation. So next let's start the action. Let's write the method for the insertion operation. So open the Python file. Here we have class BSD inside that we need to define the method for insertion operation. So here I will take DEF. If I want to define any method I need to take DEF followed by the method name. So here I want to perform insertion operation. So that's why I take the method name as insert. You can take any suitable name and the first parameter of every method will be self. So I'll take self and here self represents the object itself. And next we need one more parameter that is the data. Here we want to perform insertion operation. In the insertion operation we want to insert new node to the tree. So to insert the new node we need to mention the data of the new node. That's why here we are taking the parameter as data. So whenever we'll call this insert method we need to mention the data of the new node. Right. So now inside this we need to define the insert method body. So the first scenario or the condition which we need to chuck while performing the insertion operation is I need to chuck whether tree is empty or not. Now the question is how to chuck tree is empty or not. So for that here in this program after defining the class we'll create objects from this class. Here creating the object means creating the nodes of the tree. So when I take root equal to BSD of 10 that means I'm creating a node with data as 10 left child as none and our child as none like this. That means I can say if I didn't create any object from this class then tree will be empty because creating the object is nothing but creating the nodes of the tree. If I didn't create any object from this class then there will be no nodes in the tree. So tree is empty. But here we are discussing about insert operation and here I want to insert a new node to the empty tree using insert method and to call any method of the class first I need to take object dot method name followed by the parameters. Right. Now if I didn't create any object from the class then how to call the method of that class. And also if I create an object then I can call the method like this root insert followed by the value. But if I do this now tree is not empty because we created an object called root. So there is a node in tree after that we are inserting the another node to the tree. So that means here performing the insertion operation on empty tree using insert method is not possible. So to solve this problem what I'll do is I'll take if the key of a node is empty or none then I'll take that node as empty node and I'll ignore empty nodes in the tree. For example if I pass here none, none is the key word, none means no value. Now if I pass none as the value for the this object. So it will create an object and we'll get three field key, L child and R child and key value will be none. So I'll take this type of node as empty node and if a tree contains only one node with key as none then I'll take that tree as empty tree. So now this is an empty tree. Now I can use insert method because here we have an object root and I'm calling insert method. I'm inserting the value 20. Now what will happen is to check whether tree is empty or not what I'll do is I'll check the first node, the key of the first node. If the key of the first node is none that means tree is empty. Now how to check the key of the first node. So for example here node name is root. So we want to check root dot key here we can see root dot key root dot L child root dot R child. So I want to check root key whether it is none or not. And here in this method you can see cells. What is cells means? Cells represent object itself. Here we can see we called this insert method using the object root. So root dot insert that means here self is nothing but root. So now if I want to check root dot key is none or not I can take if self dot key is none that means tree is empty. At that time what I need to do is I need to simply assign self dot key is equal to data. If self dot key is none that means node is empty node. So at that time no need to create an extra node. Node is already present. I just need to add the data to the key. So we need to take self dot key. Next I'll take return. If I use return in the method or the function that will be the end of that function. So if this condition becomes true then we added that new node to the tree and now use return. So come out of that method. If it is not if self dot key is not none for example if we have 10 here that means here self dot key is not none it is 10. So this condition fails. If this condition fails if tree is not empty then what we need to do we need to chuck the position of the new node where we need to place that whether in the left subtree or in the right subtree. So we need to write the condition for this too. First let's check how to write the condition for left subtree. If data of the new node is less than the root nodes key then we need to place that in the left subtree right. So here what you need to do is you need to take the if condition and you need to chuck self dot key that is the root dot key as I said self is nothing but the object it is representing this object root dot key. If root dot key is greater than the data data of the new node that is nothing but data is less than the self dot key root key then we need to place that in the left subtree right. But if you want to insert the new node in the left side in the left subtree you may face two scenarios. One is left subtree can be empty for example here if this is the root node the first node and it is 10 it doesn't contain any left child or right child. So we are talking about the left subtree okay so left subtree is empty. At that time what I need to do I need to create the new node for example if I want to enter root dot insert 20 sorry left side right so key should be less than 10 so 5. So 5 will be entered and instead of none I need to store the address of this node and it will be none and none. If the left child of root node is none or this node is none then what I need to do I need to create the new node with the given value. If l child is none what I need to do I need to take root dot l child equal to create the node. Suppose if it is not none for example and now if I want to enter a new node here then here we can see this is the first node and its l child is not none it contains a left child. So that time what I need to do I need to compare the given data for example if given data is phi the data which we mentioned while calling the insert method then I need to check whether I need to place this in the left side or right side of this. Basically I need to consider this as the tree and I need to apply insert method again on this left child. I need to call this insert method on the root dot l child left child I need to use recursion here. So while inserting the new node to the left side of the root node or to the left subtree first we need to check whether l child or left child is present whether left subtree is empty or not. If it is empty then just create the new node and we are done. If it is not then what you need to do you need to call this insert method again on the root dot l child we are using recursion. Here we need to check another condition if self that is the root node l child if self dot l child that means if we have self dot l child then it is evaluated as true. If the root node does not contain the left child l child then by default its value will be none. So it becomes none if none is nothing but if false so this condition fails. So here if self dot l if the left child of root node is present then it is evaluated as true otherwise it is false. Now if it is present that means I need to perform this insert operation again. You need to perform self l child insert data. Here we are using recursion. Look if root node contains the left child then what we need to do we need to go to the left child and we need to again compare its data with the new node data whether I need to place that in the left side or right side. So for that we need to call this again. We need to perform that recursively. For example if tree is like this and if I want to insert the new node we need to compare this in the left subtree we need to find the suitable position of the new node. For that we need to compare the data of the new node with the key of the root node of every left subtree. So that is why we need to perform this operation recursively. Else if l child is not present that means root node does not have any left child. That means we need to insert the new node now. So for that self dot l child equal to so we are inserting the new node in the left child. So you need to call BSD and data. So we are using this BSD to create the new node. So when I will create a new object here self dot l child using BSD class then these three fields will be initialized like this and in this root left child the address of the new node will be stored. It will be worked like this. Now we are done with the left child part. Now we are done with the left side. If self dot key is greater than the data then we need to place the node in the left side. If it is not then we need to use else here. That means the data is greater than the root node key. That's why we need to place that in the right side. So I will copy this code like this. Here you need to do the same thing. First you need to check whether R child is present or not. If R child is present then you need to perform self R child dot insert. You need to find the position of the right child recursively. So you need to call this insert method else. You are here R child is equal to BSD data. We need to write the same code. Just you need to change L child to R child here. Now we are done with the insert method. Now if I execute root dot insert it will insert 20 in the right side of the 10. That is the root node of the three. But I can't show you now because we didn't write the traversal method till now. So I can't show you the output now because this insert method only inserts the new node to tree. It is not displaying any output right. That's why. But don't worry in the next video I will explain you how this works with the few example. Now one more thing. How to deal with the duplicate values? One way is you can ignore the duplicate value. Other way is you can place that in the left side. Other way is you can place that in the right side. If you want to place that in the left side you can use here equal to symbol. If self dot key is equal to or greater than data you can place that in the left side. Here you can use equal to or if you want to place that in the right side then actually now it is placing that in the right side right. Because here we took only greater than symbol. That's why. If you want to place that in the left side here you can include the equal symbol. But here what I will do is I will ignore the duplicate value. So here I will take the condition like this. If self dot key is equal to equal to data. So if you want to ignore the duplicate values you can take this condition return. So if self dot key if the root key is equal to equal to data it if it becomes equal to the new node data then just return. If you want to place that in the left side remove this and here you can take equal to. So when self dot key becomes equal to data we will place that in the left side. Or if you didn't take this and here equal then it will place the duplicate values in the right side. You can modify this code based on your requirement and now here. And if you want to insert a list of node then you can use loop for that. Like this you can create a list for example list one. And here you can take the list of node. You can take values here like this. Some values. Then you need to use the loop for i in list one. Then you need to call root dot insert and i. So it will insert the value of the list one one by one. I know you have confusion with this insert method because we used recursion here. Understanding recursion is not easy. That's why in the next tutorial we will trace this code with these values. I'll explain you how this program works line by line. So I'll meet you in the next tutorial. That's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. Bye. Take care.