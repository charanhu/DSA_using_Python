 Hello guys and welcome to Amuliya's Academy YouTube channel. We were discussing about binary heap data structure. Today in this tutorial we will see how to create the binary heap when list of numbers are given. We can create or build binary heap using two approach. The first approach is called as Williams method. He is the inventor of binary heap, jwj-villiams. In this method first we will take an empty heap. Then we will add the element of the list to the heap one by one. After inserting one node or element we will check whether that node is following the heap property or not. If it is not following the heap property then we will rearrange the nodes. We already discussed about this method in the previous tutorial while discussing about the insertion method. I explained to you when we want to insert list of number to heap then how to do that. So that method of insertion is called as Williams method. But today here we are not discussing about this method. As I said I already explained about this in the previous tutorial. So I will give you the link of that video in the description work. If you want to know about that method then you can watch that video. Today here we will discuss about the second method, the second approach. In this approach what we will do is first we will construct the complete binary tree from given list of numbers. We won't worry about the heap property. First we will construct the complete binary tree from the given list of numbers. After creating the complete binary tree we will start from the leaf node and we will check whether that node is following the heap property or not. We will start from the last leaf node or we can say the first node from the bottom. Next we will move to the next leaf node and next we will move to the next node and we will check the heap property of every node of the tree. If it is following the heap property then no need to do anything. If it is not following the heap property then we will rearrange the nodes. This is the second approach. We can improvise this approach that is instead of checking whether the nodes are following the heap property or not from the leaf node we can start from the last internal node. That is because to check the heap property of the nodes we are comparing the key of the node with its child nodes key. Because leaf node is a node which doesn't have any child node so instead of checking from the leaf node we can start from the last internal node or we can say the first internal node from the bottom. To check the heap property of the node we are comparing the nodes key with its child nodes key because leaf nodes are the nodes with zero child node. So instead of starting from the leaf node we can start from the last internal node or the first internal node from the bottom. So this is about the second approach. Let's take few examples. Let's take some list of numbers and let's build the binary heap. Okay so first here we have list of number 5, 1, 4, 10 and 20. Now we need to build a binary heap. So here first step is we need to build a complete binary tree. This will be the root node so I'll insert 5. Next one here this is the root node so we need to insert one here in the left side. Next four in the right side. Next 10 we can't insert here because in the complete binary tree every node can have at most two child nodes. So here two is done so we need to come here so 10 will be inserted here. Next 20. So now this is a complete binary tree right. Now if I want to make it as a binary heap then every node of this tree need to follow the heap property. To check the nodes of this tree is following heap property or not we need to start from the first internal node from the bottom. Here we can see this is the leaf node this is the leaf node this is the leaf node this is the internal node right. So this is the first internal node from the bottom this is the first internal node so 1. I'll name it this is the second internal node. So first we need to start from here whether this node is following the heap property or not. Now it depends on you whether you want to build mags heap or min heap. First let's build a mags heap okay. So I need to check whether this node is following the mags heap property. Let's compare its key with its child nodes key. So this node key is 1 child node key is 10 and 20. So this node is not following the mags heap property right. So now I need to rearrange the nodes. For that let's check the child nodes key which child node contains the maximum key because here we want mags heap so we need to search for the maximum key. This is 10 and this is 20. So this node contains the maximum key. So now I need to swap these two nodes 1 and 20. So here 20 will come here 1 here. Now here we can see this is following the mags heap property parent node is 20 child node is 10 and 1. So now here we are done. So next let's move on to the next internal node that is this node root node here. So let's see whether it is following the heap property or not. Its key is phi its child node is 20 and 4. So this node is not following the mags heap property. So we need to rearrange the nodes. So for that let's check child nodes key here this is 20 and 4. So this node contains maximum key. So we need to swap these two now 20 and phi 20 will come here and phi here. Now because we swapped or rearranged this node. Now we need to check whether this node is following the heap property or not. So I'll check its key with its child node key. Here it is 10 and 1. So this is not following the mags heap property. So I need to swap 10 and phi. So here 10 will come here and phi will come here. Now here you can see every nodes are arranged properly. Every nodes are following the mags heap property. So we'll get this mags heap from these numbers list of numbers. Now if I want to construct a main heap from this then how to do that. So for that first step is same we need to create a complete binary tree. So for that phi next step is we need to begin from the first internal node from the bottom. So this is the first internal node. So I need to check its key with its child nodes key. So one is less than 10 and 20. So this is following the main heap property. So no need to change anything. So let's move on to the next internal node. This node phi its key is phi its child node key is one and four. This node is not following the minimum heap property. So we need to rearrange the nodes here. Here in one and four one is the smallest. So we need to swap one and five. One will go here and phi here. Now we rearranged this node. So we need to check whether this node is following the heap property or not. So I'll check its key with its child nodes key 10 and 20. So it is following the minimum heap property. So no need to do anything. So now we got the minimum heap from this list of numbers. This is the mags heap and this is the main heap. Next let's take another example. To create the binary heap the first step is we need to build the complete binary tree from these numbers. So here 51. Next we have 2010. Next 4. 1. 55. 100. 200. 400. 21. 12. 7. So this is the complete binary tree. Now we need to check whether this nodes are following the heap property or not. So first let's build mags heap. So we need to check every node is following the mags heap property or not. For that first we need to start from the first internal node from the bottom. So this is the leaf node this is the leaf node. This is the leaf node this is the leaf node this is the leaf node. This is the leaf node. So this is the first internal node from the bottom. This is the second internal node from the bottom. This is the third. This is the fourth. This is the fourth. This is the last internal node. We need to start from the first internal node. So let's check whether this node is following the max heap property or not. This is 55, this is 7. So parent node key is greater than the child node key. So this is following the max heap property. So no need to do any changes here. So next let's move on to the next internal node, this node. So let's check its key with its child nodes key, 121 and 12. So this node is not following the max heap property. So we need to rearrange the nodes here. So let's check the child nodes key. Here 21 and 12, we want max heap. So we need maximum key. So I need to swap 121 here. One will come here and 21 here. Now here you can see this node is following the max heap property, 21, 1 and 12. So next let's move on to the next internal node. That is this, 4, 200 and 400. No, this node is not following the max heap property. So I need to swap 4 and 400 because in the child nodes key 200 and 400, 400 is maximum here, 404. We want max heap, right? That's why. Now we are done with this. So let's move on to the next internal node, this node key is 10 and its child node key is 55 and 100. So this is not following the max heap properties. So we need to swap 10 and 100 here. 100 will come here and 10 here. Okay, now this is following the max heap property, right? Now let's move on to the next internal node, this 2421. So here this is not following the max heap property. So we need to swap 20 and 400. We need to check the child nodes key which has maximum key and we need to swap that with the parent node here, 420, 400 will come here, 20 here. So here we swapped this node and this node contains child nodes. So we need to again check whether this node is following the heap property or not. So here we can see it is 20, it is 204. Clearly it is not following the max heap property. Here this node contains maximum key. So we need to swap these two here. It will become 20 and this is 200. Then right? Now this is done. So next let's move on to the next internal node that is this node. 51, 400 and 100. Yes, it is not following the max heap property, right? Here parents node key is less than the child nodes key. So we need to swap 51 and 400. 400 will come here and 51 here. Because we changed or rearranged these two nodes, here we need to check whether this node is now following the heap property or not. So here 51, 221. Clearly it is not following the heap property. So we need to swap 251. So 200 will come here and 51 here. Now again we swapped these two nodes. So we need to check whether this node is now following the heap property or not. So I'll check 51, 24. Yes, it is following the heap property. So no need to do any changes here. Now here you can see every node is following the heap property. After comparing this node, we don't have any other node to compare. So now here you can see every node is following the max heap property. We can create minimum heap from this list of numbers. That is the exercise for you. So build a minimum binary heap from this list of numbers. So that's it for now guys. Thank you for watching. Don't forget to subscribe to my channel. I will meet you in next class. Till then take care.