 Hello guys and welcome to Amulya's Academy YouTube channel. In the previous few tutorials we saw how DFS that is depth first search traversal algorithm works. Next, let's see how to implement DFS algorithm in Python programming language. Today, in this tutorial we will write a function for Graph traversal operation using DFS algorithm. But before that, before writing the function, you need to be clear with two points. One is here we are representing graph using adjacency list. We are using adjacency list graph representation. That means in the program we are using dictionary to represent the graph. Every node of the graph will be the key in the dictionary like this. And the values of that key is nothing but the list of adjacent node of that key. And the second point is here we are writing the function using recursion. So we are using recursive approach here. You can write this function using iterative approach also and we will discuss about that in the next tutorial. Here we have our program. Here you can see we created a dictionary called graph. It is initially empty. Next to add nodes and edges to the graph we are using add node and add edge function. So here we are defining add node and add edge function. This program also contains delete node and delete edge function. To traverse a graph delete node and delete edge function is not needed. So that's why here I will remove this. Alright here by looking at this function we can say we are writing this program using adjacency list representation. That is we are representing the graph using adjacency list. And also in this program we are writing the function for unweighted undirected graph. Alright here we need to define a function for dfs traversal algorithm. So I will take def followed by the function name. Here I will take function name as dfs. Next in the dfs algorithm we need to start the traversal operation from the starting node and you can choose any node of the graph as the starting node. So that's why here I will ask the user to choose the starting node. When we call dfs function we will mention the starting node of that graph. For example if a is the starting node when I call dfs function I will mention the starting node also. So one of the parameter of this function is starting node. Okay node you can take any variable name here. This will represent the starting node of the graph from where we need to start the traversal operation. Next after choosing the starting node what we need to do we need to visit the starting node. First step is visit starting node. So after visiting the starting node I need to choose one of the unvisited adjacent nodes of a that is starting node. Here if I take a as the starting node. Next we need to visit the adjacent node of a. So search for a adjacent node of a and in that we need to visit the only visited adjacent node of A. Visit one of the unvisited adjacent node of A for example B. After that what we need to do is we need to search for the adjacent node of B and next we need to visit unvisited adjacent node of B. One of the unvisited adjacent node of B. We need to continue doing this until we read the dead end in that path. After that we need to backtrack right. By looking at this we can say we need to visit node or print node only once. Because here we can see we need to visit the one of the unvisited adjacent node of starting node or other nodes. But how to do that? How we will get to know that a node is already visited or not? For that we can maintain a list or array of nodes which are already visited. Then when I want to visit a node I can see whether that node is already present in that list or array. If it is already present in that list or array that means that node is already visited. If it is not present in that list or array then I can say that that node is not visited till now. So you can visit that node. So here in the program we need a list or array or I can take a set also. First I will take the variable name as visited and here I will take a set. Here I am creating an empty set. You can use a list also here to store the visited nodes. But in this program set is slightly more efficient than the list. Next what I need to do is I need to pass this as the second parameter to this DFS function. Now my question is why can't I create this visited set inside the DFS function? Why to create that outside the function and why I need to pass that as the parameter to the DFS function? That is because here we are writing a recursive function right recursive function means we are calling the DFS function again and again. And at that time we don't want to reset the value of visited set. That's why we need to define this outside the function. Alright next as we can see we are traversing the graph. That's why here I will pass graph also. Here graph is a dictionary. Okay so these are the three parameters for the DFS function node that is representing the starting node visited it is a set initially it will be empty and it will store the visited nodes of the graph and next the third parameter is graph that is a dictionary. Alright so next what we need to do inside this function body in the program what I will do is before visiting any node first I will check whether that node is already visited. For every node I will do this that is I will check whether that node is already visited. How to do that? Here we already have visited set you can check like this if node not in visited. If node is present in the visited then this condition becomes false that means node is already visited so that time no need to do anything. That's why here I will check if node not in visited if the given node the node which I want to visit is not present in the visited set then only I will visit that to visit that I will print that node okay print that node if the node the given node is not present in the visited set then print that node. Next I will mark that node as visited. Now here we can see we are printing the node that means we are visiting that node so now that node is visited so what we need to do is we need to mark that node as visited after visiting that node we need to mark that node as visited. For that I will add that node to visited set to add that I will use this visited dot add node. We need to start the traversal operation from the starting node so I will take this as the starting node what I need to do I need to visit that that means I will print its data after that I need to mark this node as visited for that I will add this to set. Next what I need to do I need to search adjacent node of A right now from where we will get the adjacent node of A. Here you can see in the dictionary value of every key is nothing but the list of adjacent node of that node right here A is adjacent to BCD these are the adjacent node of A after visiting A if I want to get the adjacent node what I need to do I need to get the value of key A how to access the value of a key in dictionary you need to mention the dictionary name and key right and here you can see because this is a list and I want to access every value every node present in the list I will use a loop so here I will use a loop like this for I in graph of node so here graph of node will give you the list of adjacent node of the key node for example if node is A we will get the list of adjacent node of key A that is the list right so to get the every value separately one by one I will use a loop on that initially I value will be the first value present in the list that is the first node present in the list for example here so graph of A is this so when I apply loop on this initially I value will be the first value of this list that is B I value will be B okay now what I need to do I need to visit this node before that I need to chuck whether this node is already visited if it is already visited then do nothing if it is not visited then print this node mark this node as a visited and chuck for its adjacent node that is nothing but we are repeating these steps we need to do the same thing for B now that's why here I will call DFS recursively for I I is nothing but the first node of the this list and here you need to pass visited as well as graphs so now I is B in this example visited is a set which contains A now graph is the graph dictionary and we are done so what we are doing here is we are visiting every node recursively and how this recursive function works I will explain about that in the next tutorial with example all right so let's execute this and we'll see so here I'll call this BFS I'll take A as the starting node and here I need to pass visited and also graph that here you can say every node of graph is visited in this order if I take B as the starting node okay now next here if I mention a node which is not present in the graph for example K K is not present in the graph here you can see now if you give this and if I execute this program what will happen here you can see it will print K then it will print an error so to avoid this what you can do is you can include a condition here before visiting a node you can check whether that given node is present in graph if node not in graph if the given node is not present in the graph that means that node is not present so I'll print this method and here I'll use return statement so now if I execute this here you can see it will print this message node is not present in the graph all right next we wrote this function for unweighted undirected graph now what if I want to write this program for weighted graphs in the weighted graph we'll use nested list as the value in the dictionary for weighted graph we'll use value as nested list that's why here instead of calling I you need to call I of 0 okay here I is representing an inner list inside that the first value will be the node adjacent node that's why you need to mention I of 0 so this is about the DFS function this is a recursive function and understanding the working of recursive function is not easy that's why in the next tutorial I'll explain you this function line by line with the example so that's it for now guys thank you for watching don't forget to subscribe to my channel I will meet you in next class till then take care and be safe